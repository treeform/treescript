(def VERSION .002)

(def fs (require "fs"))

; utils
(def (json a) (JSON.stringify a))
(def (is_string obj)
  (js "!!(obj === '' || (obj && obj.charCodeAt && obj.substr))"))
(def is_list Array.isArray)
(def (is_object obj)
  (if (is_list obj) 
    false
    (js "(obj === Object(obj))")))
(def (is_number obj)
  (js "!!(obj === 0 || (obj && obj.toExponential && obj.toFixed))"))
(def (rest l) (l.slice 1))
(def (join) (js "
  var ll=arguments.length, l=[]; 
  for(var i=0; i < ll; i++) {
    var a = arguments[i];
    for(e in a) l.push(a[e]);
  }; 
  ") 
  l)
(def (list) (js "
  var ll=arguments.length, l=[]; 
  for(var i=0; i < ll; i++) {
    l.push(arguments[i]);
  }; 
  ") 
  l)
(def (table) (js "
  var ll=arguments.length, t={}; 
  for(var i=0; i < ll; i+=2) {
    t[arguments[i]] = arguments[i+1]
  }; 
  ") 
  t)
(def (str_join l str)
  (l.join str))
(def (get l i) (js "l[i]"))
(def (set l i e) (js "l[i]=e") e)
(def (err msg)
  (js "throw msg")
  false)
  
  

(def OPS (table
  ; basic math
  "+" "+"  "-" "-"  "*" "*"  "/" "/"  "%" "%"
  ; comperison
  ">" ">"  ">=" ">="  "<" "<"  "<=" "<="  "=" "==="  "!=" "!=="
  ; function like
  "inc" "++"  "dec" "--"
  ; booleans
  "and" "&&"  "or" "||"  "not" "!"))

(def QUOTES_RE (new (RegExp "^['@~#]+$")))


; trys to compile it to a number if it can
(def (try_number token)
  (def number (parseFloat token))
  (if 
    (isNaN number) token ; its not a number - a string
    (= number 0) (parseInt token) ; hande the 0xFF case
    number))

; --------------------------------------------------  
; takes a string and spits out tokens
; also takes care of comments and strings
(def (tokenize code filename)
  (def line 1)
  (def column 1)
  (def tokens (list))
  (def word (list))
  (def i 0)
  (def len code.length)
  (def (add_word)
    (if 
      (> word.length 0)
      (do 
        (def token (word.join ""))
        (: token.line line)
        (: token.filename filename)
        (: token.column column)
        (tokens.push token)
        (: word (list)))))
  (while (< i len)
    (: c (get code i))
    ; main case block
    (if
      (or (= c "\n"))
        (do (add_word)
          (: line (+ line 1))
          (: column 0))
      ; its a space
      (or (= c " ") (= c "\t"))
        (add_word)
      ; its a char that should appear by itself
      (or (= c "(") (= c ")") (QUOTES_RE.exec c))
        (do 
          (add_word) 
          (tokens.push c))
      ; its a string
      (= c "\"")
        (do 
          (add_word)
          (def next true)
          (word.push c)
          (while next
            (if (>= i len)
              (err (+ "unclosed \" " filename ":" line "," column)))
            (: i (+ i 1))
            (: column (+ column 1))
            (: c (get code i))
            (if (= c "\"") (: next false))
            (if (= c "\\") 
              (do 
                (word.push c)
                (: i (+ i 1))
                (: c (get code i))))
            (word.push c))
          (add_word))
      (= c ";")
        (do 
          (add_word)
          (def next true)
          (while (and next (< i len))
            (: i (+ i 1))
            (: c (get code i))
            (if (= c "\n") (: next false)))
          ;WART: cant return a while loop
          false)
          
      ; if its nont of the above just add it to the token
      (word.push c))
    (: i (+ i 1))
    (: column (+ column 1)))
  ; there might be an unadded word
  (add_word)
  ; return tokens
  tokens)

; --------------------------------------------------
; makes ( ) and ' behave right
(def (parse tokens)
  (def stack (list))
  (def line (list))
  ; ' quoting
  (def (squote q)
    (: qline (list q))
    (def t (tokens.shift 0))
    (if
      (= t "(")
      (do 
        (stack.push line)
        (: line qline))
      (do 
        (qline.push (try_number t)) 
        (line.push qline))))
  ; ) open perens
  (def (spush)
    (stack.push line)
    (: line (list)))
  ; ) close perens
  (def (spop)   
    (if (< stack.length 1) 
      (err "unbalanced perens, to many )"))
    (do 
      (def up (stack.pop))
      (up.push line)
      (: line up)))
  ; dispatch function
  (def (next)
    (def t (tokens.shift 0))
    (if
      (QUOTES_RE.exec t) (squote t)
      (= t "(") (spush)
      (= t ")") (spop)
      (line.push (try_number t))))
  (while (> tokens.length 0)
     (next))
  (if (> stack.length 0)
    (err "unbalanced perens, not enough )"))
  line)

; --------------------------------------------------
; the compiler function
(def (compile tree)
  (def buffer (list))
  ; add a string to the end of the buffer
  (def (wr str)
    (buffer.push str))
  ; if string match the end of buffer remove it  
  (def (rm str)
    (if (= (get buffer (- buffer.length 1)) str)
      (buffer.pop)))
      
  ; quote compiler
  (def (quotate tree)
    (console.log (JSON.stringify tree))
    (if 
      (is_list tree)
      (do 
        (wr "[")
        (def i 0)
        (while (< i tree.length)
          (quotete e)
          (: i (+ i 1)))
        (wr "]"))
      (is_string tree)
      (do 
        (wr "\"")
        (wr tree)
        (wr "\""))))
      
  (def SCOPE_MARK "//$SCOPE$")  
  (def scope_stack (list))
  (def (scope_start) 
    (scope_stack.push (list))
    (wr SCOPE_MARK))
  (def (scope_end) 
    (def vars (scope_stack.pop))
    (def i (- buffer.length 1))
    (while (!= (get buffer i) SCOPE_MARK)
      (: i (- i 1)))
    (set buffer i 
      (if vars.length 
        (+ "var " (str_join vars ",") ";\n")
        "")))
      
  
  (def (scope_add name)
    (def top (get scope_stack (- scope_stack.length 1)))
    (top.push name))
      
  (def (co_def head tree)
    (def what (get tree 1))
    (wr "(")
    (if (is_list what)
        (do
          (def fn_name (get what 0))
          (scope_add fn_name)
          (wr fn_name)
          (wr "=")
          (def tree2 (join 
            (list "fn") 
            (list (rest (get tree 1))) 
            (tree.slice 2)))
          (co_fn head tree2))
        (do 
          (scope_add what)
          (wr what)
          (wr "=")
          (sub (get tree 2))))
    (wr ")"))
    
  (def (co_set head tree)
    (wr "(")
    (wr (get tree 1))
    (wr "=")
    (sub (get tree 2))
    (wr ")"))
            
  (def (co_ops head tree)
    (def op (get OPS head))
    (def i 1)
    (wr "(")
    (while (< i tree.length)
      (sub (get tree i))
      (wr op)
      (: i (+ i 1)))
    (rm op)
    (wr ")"))
    
  (def (co_js head tree)
    (def codestr (get tree 1))
    (wr (codestr.slice 1 -1)))
    
  (def (co_if head tree)
    (def i 1)
    (while (< (+ i 1) tree.length)
      (sub (get tree i))
      (wr "?")
      (: i (+ i 1))
      (sub (get tree i))
      (wr ":")
      (: i (+ i 1)))
    (if (< i tree.length)
      (sub (get tree i))
      (wr "null")))
  
  (def (co_fn head tree)
    (wr "(function(")
    (def args (get tree 1))
    (wr args)
    (wr "){\n")
    (scope_start)
    (def i 2)
    (while (< i tree.length)
      (if (= i (- tree.length 1))
        (wr "return "))
      (sub (get tree i))
      (wr ";\n")
      (: i (+ i 1)))
    (scope_end)
    (wr "})"))

  (def (co_do head tree)
    (wr "(function(){\n")
    (def i 1)
    (while (< i tree.length)
      (if (= i (- tree.length 1))
        (wr "return "))
      (sub (get tree i))
      (wr ";\n")
      (: i (+ i 1)))
    (wr "}())"))
    
  (def (co_while head tree)
    (wr "(function(){")
    (wr "while(")
    (sub (get tree 1))
    (wr "){\n")
    (def i 2)
    (while (< i tree.length)
      (sub (get tree i))
      (wr ";\n")
      (: i (+ i 1)))
    (wr "}}())"))
        
  (def (co_new head tree)      
    (wr "(new ")
    (sub (get tree 1))
    (wr ")"))
        
  (def (co_quote head tree)
    (if
      (> tree.length 2)
      (wr (JSON.stringify (tree.slice 1)))
      (wr (JSON.stringify (get tree 1)))))
      
  (def (co_regular_fn_call head tree)
    (wr head)
    (wr "(")
    (def i 1)
    (while (< i tree.length)
      (sub (get tree i))
      (wr ",")
      (: i (+ i 1)))
    (rm ",")
    (wr ")"))
    
  ; sub expression compiler      
  (def (sub tree)
    ;(console.log "sub" tree)
    (if 
      (is_list tree)
      (do 
        (def head (get tree 0))
        (if 
          (get OPS head) 
          (co_ops head tree)
          (= head "def")
          (co_def head tree)
          (= head "js")  
          (co_js head tree)
          (= head "if")  
          (co_if head tree)
          (= head "fn")  
          (co_fn head tree)
          (= head "do")  
          (co_do head tree)
          (= head "while")  
          (co_while head tree)
          (= head "new")  
          (co_new head tree)
          (= head ":")  
          (co_set head tree)
          (= head "'")
          (co_quote head tree)
          ; regular function call 
          (co_regular_fn_call head tree)))           
      (wr tree)))
      
  (scope_start)
  
  ; loop through all top level expressions
  (def i 0)
  (while (< i tree.length)
    (sub (get tree i))
    (wr ";\n")
    (: i (+ i 1)))
    
  (scope_end)    
  ; write out the final buffer
  (buffer.join ""))

; --------------------------------------------------
; tests

; simple testing message printer
(def (test msg got needed)
  (if (!= (json got) (json needed))
    (console.log "* error testing:" msg
       "got" got "needed" needed)
    (console.log msg "ok")))

(def (test_err msg fun needed)
  (def got (js "
    function(){
       try { fun() }
       catch (e)
       { return e }
    }()"))
  (if (!= got needed)
    (console.log "* error testing:" msg
      "got" (json got) "needed" (json needed))))

(test "is_string" (is_string "foo") true)
(test "is_object" (is_object (table 'a 'b 'c 'd)) true)
(test "is_list" (is_list '(a b c d)) true)
(test "is_number" (is_number 123) true)
; some thing else
(test "not is_string" (is_string '("f" "o" "o")) false)
(test "not is_object" (is_object '(a b c d)) false)
(test "not is_list" (is_list (table 'a 'b 'c 'd)) false)
(test "not is_number" (is_number "123") false)

; tokenize tests
(test "tokanize 1" (tokenize "a b c d") '(a b c d))
(test "tokanize 2" (tokenize "(a b c d)") (list "(" "a" "b" "c" "d" ")"))
(test "tokanize 3" (tokenize "(123 abc)") (list "(" "123" "abc" ")"))
(test "tokanize 4" (tokenize "'abc") (list "'" "abc"))
(test "tokanize 5" (tokenize " \"hello world\" ") (list "\"hello world\""))
(test "tokanize 6" (tokenize " ; foo bar \n \"hello world\" ") (list "\"hello world\""))
(test "tokanize 7" (tokenize " \"hello \\\"world\" ") (list "\"hello \\\"world\""))

; tokenize errors
(test_err "unclosed string"
  (fn () (tokenize "a\n\n  \"unclosed..."))
  "unclosed \" undefined:3,15")

; parse tests
(test "parse 1" (parse (tokenize "a b c d")) '(a b c d))
(test "parse 2" (parse (tokenize "a (b c) d")) '(a (b c) d))
(test "parse 3" (parse (tokenize "a '(b '1 2) d")) '(a '(b '1 2) d))
(test "parse 4" (parse (tokenize "(print \"hello word\" 123)")) (list '(print "hello word" 123)))
(test "parse 5" (parse (tokenize "((()))")) (list (list (list (list)))))
;(test "parse 6" (parse (tokenize "'(a)")) (list (list "\'" "a")))
;(test "parse 7" (parse (tokenize "'a")) (list (list "\'" (list "a"))))
(test "parse 8" (parse (tokenize "()()()")) (list (list) (list) (list)))
(test "parse 9" (parse (tokenize 
  "(a (b 1) 2)"))
  (list (list 'a (list 'b 1) 2)))
  
; perens tests
(test_err "unbalanced perens"
  (fn () (parse (tokenize "(")))
  "unbalanced perens, not enough )")

; compile tests
(test "compile basic" (compile (parse (tokenize 
  "(console.log \"hi world\")"))) 
  "console.log(\"hi world\");\n")

; compile nested functions
(test "compile nested 1" (compile (parse (tokenize 
  "(console.log (add \"hi world\" foo))"))) 
  "console.log(add(\"hi world\",foo));\n")
(test "compile nested 2" (compile (parse (tokenize 
  "(a (b (c (d (e (f (g)))))))"))) 
  "a(b(c(d(e(f(g()))))));\n")  
(test "compile nested 3" (compile (parse (tokenize 
  "(a (b (c (d (e (f (g 1) 2) 3) 4) 5) 6) 7)"))) 
  "a(b(c(d(e(f(g(1),2),3),4),5),6),7);\n")    
(test "compile nested 4" (compile (parse (tokenize 
  "(a (b 1 2 3) (c 1 2 3))"))) 
  "a(b(1,2,3),c(1,2,3));\n")  
  
; operators
(test "operators1" (compile (parse (tokenize 
  "(+ 1 2)"))) 
  "(1+2);\n")  
(test "operators2" (compile (parse (tokenize 
  "(+ 1 2 3 4)"))) 
  "(1+2+3+4);\n") 
(test "operators3" (compile (parse (tokenize 
  "(+ 1 (/ 2 1) 3 4)"))) 
  "(1+(2/1)+3+4);\n") 
(test "operators4" (compile (parse (tokenize 
  "(= a b)"))) 
  "(a===b);\n")   
(test "operators5" (compile (parse (tokenize 
  "(!= a b)"))) 
  "(a!==b);\n")   
(test "operators6" (compile (parse (tokenize 
  "(> a b c)"))) 
  "(a>b>c);\n") 
      
; special forms 
; def 
(test "def1" (compile (parse (tokenize 
  "(def a 1 )"))) 
  "var a;\n(a=1);\n") 
(test "def2" (compile (parse (tokenize 
  "(def a (b(c d)))"))) 
  "var a;\n(a=b(c(d)));\n")   
(test "def3" (compile (parse (tokenize 
  "(def (a b c) b c)"))) 
  "var a;\n(a=(function(b,c){\nb;\nreturn c;\n}));\n") 
(test "def4" (compile (parse (tokenize 
  "(def (a) (def c 0))"))) 
  "var a;\n(a=(function(){\nvar c;\nreturn (c=0);\n}));\n") 
    
; if
(test "if1" (compile (parse (tokenize 
  "(if a b c)"))) 
  "a?b:c;\n")  
(test "if2" (compile (parse (tokenize 
  "(if a b c d e f g)"))) 
  "a?b:c?d:e?f:g;\n")  
(test "if3" (compile (parse (tokenize 
  "(if a b c d e f)"))) 
  "a?b:c?d:e?f:null;\n") 
(test "if4" (compile (parse (tokenize 
  "(if (> 1 2) a)"))) 
  "(1>2)?a:null;\n") 
  
; fn
(test "fn1" (compile (parse (tokenize 
  "(fn (a) b c)"))) 
  "(function(a){\nb;\nreturn c;\n});\n") 
(test "fn2" (compile (parse (tokenize 
  "(fn (a b c) b c)"))) 
  "(function(a,b,c){\nb;\nreturn c;\n});\n") 
(test "fn3" (compile (parse (tokenize 
  "(fn (a b c) (b c))"))) 
  "(function(a,b,c){\nreturn b(c);\n});\n") 
(test "fn4" (compile (parse (tokenize 
  "(fn () (b c))"))) 
  "(function(){\nreturn b(c);\n});\n") 
(test "fn5" (compile (parse (tokenize 
  "(fn ())"))) 
  "(function(){\n});\n") 
  
; do  
(test "do1" (compile (parse (tokenize 
  "(do a b c d e f)"))) 
  "(function(){\na;\nb;\nc;\nd;\ne;\nreturn f;\n}());\n")   

; while  
(test "while1" (compile (parse (tokenize 
  "(while a b c d e f)"))) 
  "(function(){while(a){\nb;\nc;\nd;\ne;\nf;\n}}());\n")   
    
; quote
(test "quote1" (compile (parse (tokenize 
  "'a"))) 
  "\"a\";\n") 
(test "quote2" (compile (parse (tokenize 
  "'avacado"))) 
  "\"avacado\";\n") 
(test "quote3" (compile (parse (tokenize 
  "'(a b c)"))) 
  "[\"a\",\"b\",\"c\"];\n") 
;(test "quote4" (compile (parse (tokenize 
;  "'(a)"))) 
;  "[\"a\"];\n") 

; js
(test "js1" (compile (parse (tokenize 
  "(js \"for(var i=0;i<10;i++){}\")"))) 
  "for(var i=0;i<10;i++){};\n")
(test "js2" (compile (parse (tokenize 
  "(js \"/* (comment) */\")"))) 
  "/* (comment) */;\n")
  
  

(def ts (fs.readFileSync "treescript.tree" "utf8"))
; (console.log (tokenize ts))
; (console.log (parse (tokenize ts)))
(fs.writeFileSync "test2.js" (compile (parse (tokenize ts))))

   
