(def VERSION .002)

(def fs (require 'fs))

(def OPS (table
  ; basic math
  "+" "+"  "-" "-"  "*" "*"  "/" "/"  "%" "%"
  ; comperison
  ">" ">"  ">=" ">="  "<" "<"  "<=" "<="  "=" "==="  "!=" "!=="
  ; function like
  "inc" "++"  "dec" "--"
  ; booleans
  "and" "&&"  "or" "||"  "not" "!"))

(def QUOTES_RE (new (RegExp "^['@~#]+$")))

; utils
(def (json a) (JSON.stringify a))
(def (is_string obj)
  (js "!!(obj === '' || (obj && obj.charCodeAt && obj.substr))"))
(def (is_object obj)
  (if (is_list obj) false
    (js "obj === Object(obj)")))
(def is_list Array.isArray)
(def (is_number obj)
  (js "!!(obj === 0 || (obj && obj.toExponential && obj.toFixed))"))

(def (err msg)
  (js "throw msg")
  false)

; trys to compile it to a number if it can
(def (try_number token)
  (def number (parseFloat token))
  (if 
    (isNaN number) token ; its not a number - a string
    (= number 0) (parseInt token) ; hande the 0xFF case
    number))

; --------------------------------------------------  
; takes a string and spits out tokens
; also takes care of comments and strings
(def (tokenize code filename)
  (def line 1)
  (def column 1)
  (def tokens (list))
  (def word (list))
  (def i 0)
  (def len code.length)
  (def (add_word)
    (if 
      (> word.length 0)
      (let (token (word.join ""))
        (: token.line line)
        (: token.filename filename)
        (: token.column column)
        (tokens.push token)
        (: word (list)))))
  (while (< i len)
    (: c (get code i))
    ; main case block
    (if
      (or (= c "\n"))
        (do (add_word)
          (: line (+ line 1))
          (: column 0))
      ; its a space
      (or (= c " ") (= c "\t"))
        (add_word)
      ; its a char that should appear by itself
      (or (= c "(") (= c ")") (QUOTES_RE.exec c))
        (do 
          (add_word) 
          (tokens.push c))
      ; its a string
      (= c "\"")
        (do 
          (add_word)
          (def next true)
          (word.push c)
          (while next
            (if (>= i len)
              (err (+ "unclosed \" " filename ":" line "," column)))
            (: i (+ i 1))
            (: column (+ column 1))
            (: c (get code i))
            (if (= c "\"") (: next false))
            (word.push c))
          (add_word))
      (= c ";")
        (do 
          (add_word)
          (def next true)
          (while (and next (< i len))
            (: i (+ i 1))
            (: c (get code i))
            (if (= c "\n") (: next false)))
          ;WART: cant return a while loop
          false)
          
      ; if its nont of the above just add it to the token
      (word.push c))
    (: i (+ i 1))
    (: column (+ column 1)))
  ; there might be an unadded word
  (add_word)
  ; return tokens
  tokens)

; --------------------------------------------------
; makes ( ) and ' behave right
(def (parse tokens)
  (def stack (list))
  (def line (list))
  ; ' quoting
  (def (squote q)
    (: qline (list q))
    (def t (tokens.shift 0))
    (if
      (= t "(")
      (do 
        (stack.push line)
        (: line qline))
      (do 
        (qline.push (try_number t)) 
        (line.push qline))))
  ; ) open perens
  (def (spush)
    (stack.push line)
    (: line (list)))
  ; ) close perens
  (def (spop)   
    (if (< stack.length 1) 
      (err "unbalanced perens"))
    (let (up (stack.pop))
      (up.push line)
      (: line up)))
  ; dispatch function
  (def (next)
    (def t (tokens.shift 0))
    (if
      (QUOTES_RE.exec t) (squote t)
      (= t "(") (spush)
      (= t ")") (spop)
      (line.push (try_number t))))
  (while (> tokens.length 0)
     (next))
  (if (> stack.length 0)
    (err "unbalanced perens"))
  line)

; --------------------------------------------------
; the compiler function
(def (compile tree)
  (def buffer (list))
  ; add a string to the end of the buffer
  (def (wr str)
    (buffer.push str))
  ; if string match the end of buffer remove it  
  (def (rm str)
    (if (= (get buffer (- buffer.length 1)) str)
      (buffer.pop)))
      
  ; quote compiler
  (def (quotate tree)
    (console.log (JSON.stringify tree))
    (if 
      (is_list tree)
      (do 
        (wr "[")
        (def i 0)
        (while (< i tree.length)
          (quotete e)
          (: i (+ i 1)))
        (wr "]"))
      (is_string tree)
      (do 
        (wr "\"")
        (wr tree)
        (wr "\""))))
      
  ; sub expression compiler      
  (def (sub tree)
    ;(console.log "sub" tree)
    (if 
      (is_list tree)
        (do 
          (def head (get tree 0))
          (if 
            (get OPS head)
            (do
              (def op (get OPS head))
              (def i 1)
              (wr "(")
              (while (< i tree.length)
                (sub (get tree i))
                (wr op)
                (: i (+ i 1)))
              (rm op)
              (wr ")"))
            (= head "js")
            (do 
              (def codestr (get tree 1))
              (wr (codestr.slice 1 -1)))
            (= head "if")
            (do
              (def i 1)
              (while (< (+ i 1) tree.length)
                (wr (get tree i))
                (wr "?")
                (: i (+ i 1))
                (wr (get tree i))
                (wr ":")
                (: i (+ i 1)))
              (if (< i tree.length)
                (wr (get tree i))
                (wr "null")))
            (= head "fn")
            (do
              (wr "(function(")
              (def args (get tree 1))
              (wr args)
              (wr "){\n")
              (def i 2)
              (while (< i tree.length)
                (sub (get tree i))
                (wr ";\n")
                (: i (+ i 1)))
              (wr "})"))
            (= head "'")
            (if
              (> tree.length 2)
              (wr (JSON.stringify (tree.slice 1)))
              (wr (JSON.stringify (get tree 1))))
            ; regular function call            
            (do
              (wr head)
                (wr "(")
                (def i 1)
                (while (< i tree.length)
                  (sub (get tree i))
                  (wr ",")
                  (: i (+ i 1)))
                (rm ",")
                (wr ")")
                ;(console.log buffer)
                )))
      (wr tree)))
  ; loop through all top level expressions
  (def i 0)
  (while (< i tree.length)
    (sub (get tree i))
    (wr ";\n")
    (: i (+ i 1)))
  ; write out the final buffer
  (buffer.join ""))

; --------------------------------------------------
; tests

; simple testing message printer
(def (test msg got needed)
  (if (!= (json got) (json needed))
    (console.log "* error testing:" msg
       "got" got "needed" needed)
    (console.log msg "ok")))

(def (test_err msg fun needed)
  (def got (js "
    function(){
       try { fun() }
       catch (e)
       { return e }
    }()"))
  (if (!= got needed)
    (console.log "* error testing:" msg
      "got" (json got) "needed" (json needed))))

(test "is_string" (is_string "foo") true)
(test "is_object" (is_object '(a: b c: d)) true)
(test "is_list" (is_list '(a b c d)) true)
(test "is_number" (is_number 123) true)
; some thing else
(test "not is_string" (is_string '("f" "o" "o")) false)
(test "not is_object" (is_object '(a b c d)) false)
(test "not is_list" (is_list '(a: b c: d)) false)
(test "not is_number" (is_number "123") false)

; tokenize tests
(test "tokanize 1" (tokenize "a b c d") '(a b c d))
(test "tokanize 2" (tokenize "(a b c d)") (list "(" "a" "b" "c" "d" ")"))
(test "tokanize 3" (tokenize "(123 abc)") (list "(" "123" "abc" ")"))
(test "tokanize 4" (tokenize "'abc") (list "'" "abc"))
(test "tokanize 5" (tokenize " \"hello world\" ") (list "\"hello world\""))
(test "tokanize 6" (tokenize " ; foo bar \n \"hello world\" ") (list "\"hello world\""))

; tokenize errors
(test_err "unclosed string"
  (fn () (tokenize "a\n\n  \"unclosed..."))
  "unclosed \" undefined:3,15")

; parse tests
(test "parse 1" (parse (tokenize "a b c d")) '(a b c d))
(test "parse 2" (parse (tokenize "a (b c) d")) '(a (b c) d))
(test "parse 3" (parse (tokenize "a '(b '1 2) d")) '(a '(b '1 2) d))
(test "parse 4" (parse (tokenize "(print \"hello word\" 123)")) (list '(print "hello word" 123)))
(test "parse 5" (parse (tokenize "((()))")) (list (list (list (list)))))
;(test "parse 6" (parse (tokenize "'(a)")) (list (list "\'" "a")))
;(test "parse 7" (parse (tokenize "'a")) (list (list "\'" (list "a"))))

; perens tests
(test_err "unbalanced perens"
  (fn () (parse (tokenize "(")))
  "unbalanced perens")

; compile tests
(test "compile basic" (compile (parse (tokenize 
  "(console.log \"hi world\")"))) 
  "console.log(\"hi world\");\n")

; compile nested functions
(test "compile nested 1" (compile (parse (tokenize 
  "(console.log (add \"hi world\" foo))"))) 
  "console.log(add(\"hi world\",foo));\n")
(test "compile nested 2" (compile (parse (tokenize 
  "(a (b (c (d (e (f (g)))))))"))) 
  "a(b(c(d(e(f(g()))))));\n")  
(test "compile nested 3" (compile (parse (tokenize 
  "(a (b (c (d (e (f (g 1) 2) 3) 4) 5) 6) 7)"))) 
  "a(b(c(d(e(f(g(1),2),3),4),5),6),7);\n")    
(test "compile nested 4" (compile (parse (tokenize 
  "(a (b 1 2 3) (c 1 2 3))"))) 
  "a(b(1,2,3),c(1,2,3));\n")  
  
; operators
(test "operators1" (compile (parse (tokenize 
  "(+ 1 2)"))) 
  "(1+2);\n")  
(test "operators2" (compile (parse (tokenize 
  "(+ 1 2 3 4)"))) 
  "(1+2+3+4);\n") 
(test "operators3" (compile (parse (tokenize 
  "(+ 1 (/ 2 1) 3 4)"))) 
  "(1+(2/1)+3+4);\n") 
(test "operators4" (compile (parse (tokenize 
  "(= a b)"))) 
  "(a===b);\n")   
(test "operators5" (compile (parse (tokenize 
  "(!= a b)"))) 
  "(a!==b);\n")   
(test "operators6" (compile (parse (tokenize 
  "(> a b c)"))) 
  "(a>b>c);\n") 
      
; special forms 
; if
(test "if1" (compile (parse (tokenize 
  "(if a b c)"))) 
  "a?b:c;\n")  
(test "if2" (compile (parse (tokenize 
  "(if a b c d e f g)"))) 
  "a?b:c?d:e?f:g;\n")  
(test "if3" (compile (parse (tokenize 
  "(if a b c d e f)"))) 
  "a?b:c?d:e?f:null;\n") 
  
; fn
(test "fn1" (compile (parse (tokenize 
  "(fn (a) b c)"))) 
  "(function(a){\nb;\nc;\n});\n") 
(test "fn2" (compile (parse (tokenize 
  "(fn (a b c) b c)"))) 
  "(function(a,b,c){\nb;\nc;\n});\n") 
(test "fn3" (compile (parse (tokenize 
  "(fn (a b c) (b c))"))) 
  "(function(a,b,c){\nb(c);\n});\n") 
(test "fn4" (compile (parse (tokenize 
  "(fn () (b c))"))) 
  "(function(){\nb(c);\n});\n") 
(test "fn5" (compile (parse (tokenize 
  "(fn ())"))) 
  "(function(){\n});\n") 
  
; quote
(test "quote1" (compile (parse (tokenize 
  "'a"))) 
  "\"a\";\n") 
(test "quote2" (compile (parse (tokenize 
  "'avacado"))) 
  "\"avacado\";\n") 
(test "quote3" (compile (parse (tokenize 
  "'(a b c)"))) 
  "[\"a\",\"b\",\"c\"];\n") 
;(test "quote4" (compile (parse (tokenize 
;  "'(a)"))) 
;  "[\"a\"];\n") 

; js
(test "js1" (compile (parse (tokenize 
  "(js \"for(var i=0;i<10;i++){}\")"))) 
  "for(var i=0;i<10;i++){};\n")
(test "js2" (compile (parse (tokenize 
  "(js \"/* (comment) */\")"))) 
  "/* (comment) */;\n")
   
